<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cozy Coloring Studio</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    body { margin: 0; }
    input[type="range"] { accent-color: #f59e0b; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    
    const Icon = ({ name, size = 24, className = "" }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current && lucide.icons[name]) {
          iconRef.current.innerHTML = '';
          const icon = lucide.createElement(lucide.icons[name]);
          icon.setAttribute('width', size);
          icon.setAttribute('height', size);
          iconRef.current.appendChild(icon);
        }
      }, [name, size]);
      return <span ref={iconRef} className={className} style={{display: 'inline-flex', verticalAlign: 'middle'}} />;
    };

    const CozyColoringApp = () => {
      const canvasRef = useRef(null);
      const colorWheelRef = useRef(null);
      const lineWorkRef = useRef(null);
      const fileInputRef = useRef(null);
      const [ctx, setCtx] = useState(null);
      const [mode, setMode] = useState('fill');
      const [currentColor, setCurrentColor] = useState('#FF6B9D');
      const [hue, setHue] = useState(340);
      const [saturation, setSaturation] = useState(100);
      const [lightness, setLightness] = useState(70);
      const [isDrawing, setIsDrawing] = useState(false);
      const [brushSize, setBrushSize] = useState(15);
      const [eraserSize, setEraserSize] = useState(20);
      const [imageData, setImageData] = useState(null);
      const [history, setHistory] = useState([]);
      const [currentImageName, setCurrentImageName] = useState('Generate or upload a coloring page');
      const [isDragging, setIsDragging] = useState(false);
      
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyInput, setShowApiKeyInput] = useState(false);
      const [apiKeyTemp, setApiKeyTemp] = useState('');
      
      const [imagePrompt, setImagePrompt] = useState('');
      const [isGeneratingImage, setIsGeneratingImage] = useState(false);
      const [imageError, setImageError] = useState(null);
      
      const [colorPrompt, setColorPrompt] = useState('');
      const [suggestedColors, setSuggestedColors] = useState([]);
      const [isLoadingColors, setIsLoadingColors] = useState(false);
      const [colorError, setColorError] = useState(null);
      
      const [recentColors, setRecentColors] = useState([]);
      
      useEffect(() => {
        const savedKey = localStorage.getItem('gemini_api_key');
        if (savedKey) setApiKey(savedKey);
      }, []);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) {
          const context = canvas.getContext('2d', { willReadFrequently: true });
          setCtx(context);
          context.fillStyle = 'white';
          context.fillRect(0, 0, canvas.width, canvas.height);
          const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
          setImageData(imgData);
          lineWorkRef.current = imgData;
          setHistory([imgData]);
        }
        
        const colorWheel = colorWheelRef.current;
        if (colorWheel) {
          const wheelCtx = colorWheel.getContext('2d');
          const centerX = colorWheel.width / 2, centerY = colorWheel.height / 2;
          const radius = colorWheel.width / 2 - 5;
          for (let angle = 0; angle < 360; angle++) {
            const startAngle = (angle - 90) * Math.PI / 180;
            const endAngle = (angle + 1 - 90) * Math.PI / 180;
            wheelCtx.beginPath();
            wheelCtx.moveTo(centerX, centerY);
            wheelCtx.arc(centerX, centerY, radius, startAngle, endAngle);
            wheelCtx.closePath();
            wheelCtx.fillStyle = `hsl(${angle}, 100%, 50%)`;
            wheelCtx.fill();
          }
          wheelCtx.beginPath();
          wheelCtx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
          wheelCtx.fillStyle = 'white';
          wheelCtx.fill();
          wheelCtx.strokeStyle = '#ccc';
          wheelCtx.lineWidth = 2;
          wheelCtx.stroke();
        }
      }, []);

      const hslToHex = (h, s, l) => {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = (n) => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      };
      
      const rgbToHex = (r, g, b) => '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      
      const hexToHsl = (hex) => {
        let r = parseInt(hex.slice(1, 3), 16) / 255;
        let g = parseInt(hex.slice(3, 5), 16) / 255;
        let b = parseInt(hex.slice(5, 7), 16) / 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) { h = s = 0; }
        else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
      };

      const handleColorWheelClick = (e) => {
        const colorWheel = colorWheelRef.current;
        const rect = colorWheel.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const centerX = colorWheel.width / 2, centerY = colorWheel.height / 2;
        const dx = x - centerX, dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = colorWheel.width / 2 - 5;
        if (distance <= radius * 0.3) {
          setHue(0); setSaturation(0); setLightness(95);
          setCurrentColor(hslToHex(0, 0, 95));
        } else if (distance <= radius) {
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          angle = (angle + 90 + 360) % 360;
          setHue(Math.round(angle)); setSaturation(100); setLightness(50);
          setCurrentColor(hslToHex(Math.round(angle), 100, 50));
        }
      };

      useEffect(() => {
        setCurrentColor(hslToHex(hue, saturation, lightness));
      }, [hue, saturation, lightness]);

      const saveToHistory = () => {
        if (!ctx || !canvasRef.current) return;
        const imgData = ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
        setHistory(prev => [...prev, imgData]);
      };

      const undo = () => {
        if (history.length <= 1) return;
        const newHistory = [...history];
        newHistory.pop();
        setHistory(newHistory);
        const previousState = newHistory[newHistory.length - 1];
        if (ctx && previousState) {
          ctx.putImageData(previousState, 0, 0);
          setImageData(previousState);
        }
      };

      const isBlackPixel = (data, index) => data[index] < 50 && data[index + 1] < 50 && data[index + 2] < 50;

      const protectLinework = (newImageData) => {
        if (!lineWorkRef.current) return newImageData;
        const linework = lineWorkRef.current.data;
        const newData = newImageData.data;
        for (let i = 0; i < linework.length; i += 4) {
          if (isBlackPixel(linework, i)) {
            newData[i] = 0; newData[i + 1] = 0; newData[i + 2] = 0; newData[i + 3] = 255;
          }
        }
        return newImageData;
      };

      const getColorAtPoint = (x, y) => {
        if (!ctx || !imageData) return null;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const canvasX = Math.floor((x - rect.left) * scaleX);
        const canvasY = Math.floor((y - rect.top) * scaleY);
        const index = (canvasY * canvas.width + canvasX) * 4;
        return { r: imageData.data[index], g: imageData.data[index + 1], b: imageData.data[index + 2], a: imageData.data[index + 3] };
      };

      const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
      };

      const floodFill = (startX, startY, fillColor) => {
        if (!ctx || !imageData) return;
        const canvas = canvasRef.current;
        const targetColor = getColorAtPoint(startX, startY);
        if (!targetColor || isBlackPixel([targetColor.r, targetColor.g, targetColor.b], 0)) return;
        const fillRgb = hexToRgb(fillColor);
        if (!fillRgb || (targetColor.r === fillRgb.r && targetColor.g === fillRgb.g && targetColor.b === fillRgb.b)) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const x = Math.floor((startX - rect.left) * scaleX), y = Math.floor((startY - rect.top) * scaleY);
        const newImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = newImageData.data;
        const stack = [[x, y]];
        const visited = new Set();
        
        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          const key = `${cx},${cy}`;
          if (visited.has(key) || cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
          const index = (cy * canvas.width + cx) * 4;
          if (isBlackPixel(pixels, index)) continue;
          
          const match = Math.abs(pixels[index] - targetColor.r) < 20 && Math.abs(pixels[index+1] - targetColor.g) < 20 && Math.abs(pixels[index+2] - targetColor.b) < 20;
          if (!match) continue;

          visited.add(key);
          pixels[index] = fillRgb.r; pixels[index + 1] = fillRgb.g; pixels[index + 2] = fillRgb.b; pixels[index + 3] = 255;
          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }
        
        const protectedData = protectLinework(newImageData);
        ctx.putImageData(protectedData, 0, 0);
        setImageData(protectedData);
        saveToHistory();
      };
      
      const pickColorFromCanvas = (e) => {
        const color = getColorAtPoint(e.clientX, e.clientY);
        if (color && !isBlackPixel([color.r, color.g, color.b], 0)) {
          const hex = rgbToHex(color.r, color.g, color.b);
          selectColor(hex);
        }
      };

      const handleCanvasClick = (e) => {
        if (mode === 'fill') floodFill(e.clientX, e.clientY, currentColor);
        else if (mode === 'eyedropper') { pickColorFromCanvas(e); setMode('fill'); }
      };

      const handleMouseDown = (e) => { if (mode === 'brush' || mode === 'eraser') { setIsDrawing(true); draw(e); } };
      const handleMouseMove = (e) => { if ((mode === 'brush' || mode === 'eraser') && isDrawing) draw(e); };
      const handleMouseUp = () => { if (isDrawing) { setIsDrawing(false); saveToHistory(); } };

      const draw = (e) => {
        if (!ctx) return;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX, y = (e.clientY - rect.top) * scaleY;
        
        if (mode === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fillStyle = 'rgba(0,0,0,1)';
          ctx.beginPath(); ctx.arc(x, y, eraserSize, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        } else {
          ctx.fillStyle = currentColor;
          ctx.beginPath(); ctx.arc(x, y, brushSize, 0, Math.PI * 2); ctx.fill();
        }
        const newData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const protectedData = protectLinework(newData);
        ctx.putImageData(protectedData, 0, 0);
        setImageData(protectedData);
      };

      const resetCanvas = () => {
        if (!ctx || !lineWorkRef.current) return;
        ctx.putImageData(lineWorkRef.current, 0, 0);
        setImageData(lineWorkRef.current);
        setHistory([lineWorkRef.current]);
      };

      const downloadImage = () => {
        const link = document.createElement('a');
        link.download = `cozy-coloring-${Date.now()}.png`;
        link.href = canvasRef.current.toDataURL();
        link.click();
      };

      const loadImageToCanvas = (imageSource, name) => {
        if (!ctx || !canvasRef.current) return;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = canvasRef.current;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const drawWidth = img.width * scale, drawHeight = img.height * scale;
          const x = (canvas.width - drawWidth) / 2, y = (canvas.height - drawHeight) / 2;
          ctx.drawImage(img, x, y, drawWidth, drawHeight);
          
          const imgDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imgDataObj.data;
          for (let i = 0; i < pixels.length; i += 4) {
            const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
            const val = avg > 150 ? 255 : 0;
            pixels[i] = val; pixels[i + 1] = val; pixels[i + 2] = val; pixels[i + 3] = 255;
          }
          ctx.putImageData(imgDataObj, 0, 0);
          
          const linework = ctx.getImageData(0, 0, canvas.width, canvas.height);
          lineWorkRef.current = linework;
          setImageData(linework);
          setHistory([linework]);
          setCurrentImageName(name);
        };
        img.src = imageSource;
      };

      const handleImageUpload = (e) => { 
        if (e.target.files[0]) {
          const reader = new FileReader();
          reader.onload = (ev) => loadImageToCanvas(ev.target.result, e.target.files[0].name);
          reader.readAsDataURL(e.target.files[0]);
        }
      };
      
      const saveApiKey = () => {
        if (apiKeyTemp.trim()) {
          localStorage.setItem('gemini_api_key', apiKeyTemp.trim());
          setApiKey(apiKeyTemp.trim());
          setShowApiKeyInput(false);
          setApiKeyTemp('');
        }
      };
      
      const generateColoringPage = async () => {
        if (!imagePrompt.trim() || isGeneratingImage) return;
        if (!apiKey) { setShowApiKeyInput(true); return; }
        
        setIsGeneratingImage(true);
        setImageError(null);
        
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: `Generate a black and white coloring book page of: ${imagePrompt}. Style: bold black outlines, white background, no shading, high contrast, clean minimalist line art.` }] }],
              generationConfig: { response_mime_type: "image/png" }
            })
          });
          
          const data = await response.json();
          const base64Image = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
          
          if (base64Image) {
            loadImageToCanvas(`data:image/png;base64,${base64Image}`, imagePrompt);
            setImagePrompt('');
          } else {
            throw new Error('Could not generate image. Ensure your API key has Gemini 2.0 Flash access.');
          }
        } catch (err) {
          setImageError(err.message);
        } finally {
          setIsGeneratingImage(false);
        }
      };
      
      const suggestColors = async () => {
        if (!colorPrompt.trim() || isLoadingColors || !apiKey) return;
        setIsLoadingColors(true);
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: `Suggest 8 hex colors for coloring: ${colorPrompt}. Return ONLY a JSON array like: [{"name": "Sky Blue", "hex": "#87CEEB"}]` }] }]
            })
          });
          const data = await response.json();
          const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
          const match = text.match(/\[.*\]/s);
          if (match) setSuggestedColors(JSON.parse(match[0]));
        } catch (err) { setColorError('Failed to get colors'); }
        finally { setIsLoadingColors(false); }
      };
      
      const selectColor = (hex) => {
        setCurrentColor(hex);
        const hsl = hexToHsl(hex);
        setHue(hsl.h); setSaturation(hsl.s); setLightness(hsl.l);
        setRecentColors(prev => [hex, ...prev.filter(c => c !== hex)].slice(0, 10));
      };

      return (
        <div className="min-h-screen bg-orange-50 p-4 md:p-8">
          <div className="max-w-7xl mx-auto">
            <header className="text-center mb-8">
              <h1 className="text-4xl font-bold text-orange-600 flex items-center justify-center gap-3">
                <Icon name="Palette" size={36} /> Cozy Coloring Studio
              </h1>
              <p className="text-orange-800 italic mt-2">Create and color your own AI masterpieces!</p>
            </header>
            
            <div className="grid lg:grid-cols-[1fr,350px] gap-8">
              {/* Main Canvas Area */}
              <div className="space-y-4">
                <div className="bg-white p-4 rounded-3xl shadow-xl border-4 border-orange-200">
                  <div className="flex justify-between items-center mb-3 px-2">
                    <span className="text-orange-700 font-medium truncate max-w-[70%]">{currentImageName}</span>
                    <div className="flex gap-2">
                      {['fill', 'brush', 'eraser', 'eyedropper'].map(m => (
                        <button key={m} onClick={() => setMode(m)} 
                          className={`p-2 rounded-xl transition-all ${mode === m ? 'bg-orange-500 text-white shadow-lg scale-110' : 'bg-orange-100 text-orange-600 hover:bg-orange-200'}`}
                          title={m.charAt(0).toUpperCase() + m.slice(1)}>
                          <Icon name={m === 'fill' ? 'Droplet' : m === 'brush' ? 'Paintbrush' : m === 'eraser' ? 'Eraser' : 'Pipette'} size={20} />
                        </button>
                      ))}
                    </div>
                  </div>
                  
                  <div className="relative aspect-square bg-white rounded-xl overflow-hidden cursor-crosshair border-2 border-orange-50">
                    <canvas ref={canvasRef} width={800} height={800}
                      className="w-full h-full"
                      onClick={handleCanvasClick} onMouseDown={handleMouseDown}
                      onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} />
                  </div>
                  
                  {(mode === 'brush' || mode === 'eraser') && (
                    <div className="mt-4 flex items-center gap-4 bg-orange-50 p-3 rounded-2xl">
                      <span className="text-sm font-bold text-orange-700 w-12">{mode === 'brush' ? 'Brush' : 'Erase'}</span>
                      <input type="range" min="5" max="50" value={mode === 'brush' ? brushSize : eraserSize}
                        onChange={(e) => mode === 'brush' ? setBrushSize(Number(e.target.value)) : setEraserSize(Number(e.target.value))}
                        className="flex-1 h-2 bg-orange-200 rounded-lg appearance-none cursor-pointer" />
                    </div>
                  )}
                </div>
              </div>

              {/* Sidebar Controls */}
              <div className="space-y-6">
                {/* AI Generation */}
                <div className="bg-white p-6 rounded-3xl shadow-xl border-4 border-purple-200">
                  <h3 className="font-bold text-purple-700 flex items-center gap-2 mb-4">
                    <Icon name="Sparkles" size={20} /> AI Page Generator
                  </h3>
                  
                  {!apiKey || showApiKeyInput ? (
                    <div className="space-y-3 mb-4">
                      <input type="password" placeholder="Paste Gemini API Key" value={apiKeyTemp}
                        onChange={(e) => setApiKeyTemp(e.target.value)}
                        className="w-full p-3 border-2 border-purple-100 rounded-xl focus:border-purple-400 outline-none text-sm" />
                      <button onClick={saveApiKey} className="w-full py-2 bg-purple-500 text-white rounded-xl font-bold hover:bg-purple-600">Save Key</button>
                    </div>
                  ) : (
                    <div className="space-y-3">
                      <input type="text" placeholder="e.g. 'a cute baby dragon'" value={imagePrompt}
                        onChange={(e) => setImagePrompt(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && generateColoringPage()}
                        className="w-full p-3 border-2 border-orange-100 rounded-xl focus:border-orange-400 outline-none" />
                      <button onClick={generateColoringPage} disabled={isGeneratingImage || !imagePrompt}
                        className={`w-full py-3 rounded-xl text-white font-bold transition-all shadow-md ${isGeneratingImage ? 'bg-gray-400' : 'bg-gradient-to-r from-purple-500 to-pink-500 hover:scale-105'}`}>
                        {isGeneratingImage ? '✨ Creating...' : '✨ Generate Page'}
                      </button>
                      <button onClick={() => setShowApiKeyInput(true)} className="text-[10px] text-purple-400 w-full text-center hover:underline">Change API Key</button>
                    </div>
                  )}
                  {imageError && <p className="text-red-500 text-xs mt-2">{imageError}</p>}
                </div>

                {/* Color Palette */}
                <div className="bg-white p-6 rounded-3xl shadow-xl border-4 border-orange-200">
                  <h3 className="font-bold text-orange-700 flex items-center gap-2 mb-4">
                    <Icon name="Palette" size={20} /> Color Palette
                  </h3>
                  
                  <div className="flex items-center gap-6 justify-center mb-6">
                    <canvas ref={colorWheelRef} width={150} height={150} onClick={handleColorWheelClick}
                      className="w-24 h-24 cursor-pointer hover:scale-110 transition-transform" />
                    <div className="text-center">
                      <div className="w-16 h-16 rounded-2xl border-4 border-orange-100 shadow-inner mb-2" style={{ backgroundColor: currentColor }} />
                      <code className="text-xs font-bold text-orange-400 uppercase">{currentColor}</code>
                    </div>
                  </div>

                  {recentColors.length > 0 && (
                    <div className="grid grid-cols-5 gap-2 mb-6">
                      {recentColors.map((c, i) => (
                        <button key={i} onClick={() => selectColor(c)} className="w-full aspect-square rounded-lg border-2 border-white shadow-sm" style={{ backgroundColor: c }} />
                      ))}
                    </div>
                  )}

                  {/* AI Color Suggestions */}
                  <div className="pt-4 border-t-2 border-orange-50">
                    <div className="flex gap-2">
                      <input type="text" placeholder="Theme (e.g. 'ocean')" value={colorPrompt}
                        onChange={(e) => setColorPrompt(e.target.value)}
                        className="flex-1 p-2 text-sm border-2 border-orange-100 rounded-lg outline-none" />
                      <button onClick={suggestColors} className="p-2 bg-orange-500 text-white rounded-lg"><Icon name="Zap" size={16} /></button>
                    </div>
                    <div className="grid grid-cols-4 gap-2 mt-3">
                      {suggestedColors.map((c, i) => (
                        <button key={i} onClick={() => selectColor(c.hex)} className="w-full aspect-square rounded-lg shadow-sm" style={{ backgroundColor: c.hex }} title={c.name} />
                      ))}
                    </div>
                  </div>
                </div>

                {/* File Actions */}
                <div className="grid grid-cols-2 gap-3">
                  <button onClick={undo} disabled={history.length <= 1} className="flex items-center justify-center gap-2 p-3 bg-blue-500 text-white rounded-2xl font-bold hover:bg-blue-600 disabled:bg-gray-200">
                    <Icon name="Undo2" size={18} /> Undo
                  </button>
                  <button onClick={downloadImage} className="flex items-center justify-center gap-2 p-3 bg-emerald-500 text-white rounded-2xl font-bold hover:bg-emerald-600">
                    <Icon name="Download" size={18} /> Save
                  </button>
                  <button onClick={resetCanvas} className="flex items-center justify-center gap-2 p-3 bg-amber-500 text-white rounded-2xl font-bold hover:bg-amber-600">
                    <Icon name="RotateCcw" size={18} /> Clear
                  </button>
                  <label className="flex items-center justify-center gap-2 p-3 bg-indigo-500 text-white rounded-2xl font-bold hover:bg-indigo-600 cursor-pointer">
                    <Icon name="Upload" size={18} /> Open
                    <input type="file" className="hidden" onChange={handleImageUpload} accept="image/*" />
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CozyColoringApp />);
  </script>
</body>
</html>
